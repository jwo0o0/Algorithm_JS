# 정렬

## 선택 정렬

매 단계에서 **가장 작은 원소를 선택**해서 앞으로 보내는 정렬 방법

- 최악의 경우 시간 복잡도 O(N^2)
- 비효율적인 정렬 알고리즘 중 하나

### 동작 방식

1.  각 단계에서 가장 작은 원소를 선택
2.  현재까지 처리되지 않은 원소들 중 가장 앞의 원소와 위치를 교체

```javascript
function selectionSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    let minIdx = i;
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[minIdx] > arr[j]) minIdx = j;
    }
    //swap
    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
  }
}
```

## 버블 정렬

단순히 인접한 두 원소를 확인하여, 정렬이 안 되어 있다면 위치를 서로 변경한다.

- 최악의 경우 시간 복잡도 O(N^2)

### 동작 방식

1. 각 단계에서 인접한 두 개의 원소를 비교해 필요시 위치를 변경한다.
   (첫째와 둘째를 비교, 둘째와 셋째를 비교, 셋째와 넷째를 비교 ...)
2. 한 번의 단계가 수행되면, 가장 큰 원소가 맨 뒤로 이동한다. 다음 단계에서는 맨 뒤로 이동한 데이터는 정렬에서 제외


```javascript
function bubbleSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
    }
    console.log(arr);
  }
}

```

## 삽입 정렬

각 숫자를 적절한 위치에 삽입하는 정렬 기법

- 최악의 경우 시간 복잡도 O(N^2)
- 이미 많이 정렬되어 있는 경우 빠르게 동작

### 동작 방식

1. 각 단계에서 현재 원소가 삽입될 위치를 찾는다.
2. 적절한 위치에 도달할 때까지 반복적으로 왼쪽으로 이동한다.

### 예시

- 처음에 첫번째 원소가 정렬이 되어있다고 가정한다.

[정렬 완료 / 아직]

[2, / 4, 3, 1, 9, 6, 8, 7, 5] 시작

[2, 4, / 3, 1, 9, 6, 8, 7, 5] 4의 자리를 찾는다.

[2, 3, 4, / 1, 9, 6, 8, 7, 5] 3의 자리를 찾는다.

[1, 2, 3, 4, / 9, 6, 8, 7, 5] 1의 자리를 찾는다.

```javascript
function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    for (let j = i; j > 0; j--) {
      if (arr[j] < arr[j - 1]) {
        [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]];
      } else { //자기보다 작은 데이터를 만나면 멈춤
        break;
      }
    }
  }
}
```

## 병합 정렬
