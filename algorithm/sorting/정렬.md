# 정렬

## 선택 정렬

매 단계에서 **가장 작은 원소를 선택**해서 앞으로 보내는 정렬 방법

- 최악의 경우 시간 복잡도 O(N^2)
- 비효율적인 정렬 알고리즘 중 하나

### 동작 방식

1.  각 단계에서 가장 작은 원소를 선택
2.  현재까지 처리되지 않은 원소들 중 가장 앞의 원소와 위치를 교체

```javascript
function selectionSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    let minIdx = i;
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[minIdx] > arr[j]) minIdx = j;
    }
    //swap
    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
  }
}
```

## 버블 정렬

단순히 인접한 두 원소를 확인하여, 정렬이 안 되어 있다면 위치를 서로 변경한다.

- 최악의 경우 시간 복잡도 O(N^2)

### 동작 방식

1. 각 단계에서 인접한 두 개의 원소를 비교해 필요시 위치를 변경한다.
   (첫째와 둘째를 비교, 둘째와 셋째를 비교, 셋째와 넷째를 비교 ...)
2. 한 번의 단계가 수행되면, 가장 큰 원소가 맨 뒤로 이동한다. 다음 단계에서는 맨 뒤로 이동한 데이터는 정렬에서 제외

```javascript
function bubbleSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
    }
    console.log(arr);
  }
}
```

## 삽입 정렬

각 숫자를 적절한 위치에 삽입하는 정렬 기법

- 최악의 경우 시간 복잡도 O(N^2)
- 이미 많이 정렬되어 있는 경우 빠르게 동작

### 동작 방식

1. 각 단계에서 현재 원소가 삽입될 위치를 찾는다.
2. 적절한 위치에 도달할 때까지 반복적으로 왼쪽으로 이동한다.

### 예시

- 처음에 첫번째 원소가 정렬이 되어있다고 가정한다.

[정렬 완료 / 아직]

[2, / 4, 3, 1, 9, 6, 8, 7, 5] 시작

[2, 4, / 3, 1, 9, 6, 8, 7, 5] 4의 자리를 찾는다.

[2, 3, 4, / 1, 9, 6, 8, 7, 5] 3의 자리를 찾는다.

[1, 2, 3, 4, / 9, 6, 8, 7, 5] 1의 자리를 찾는다.

```javascript
function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    for (let j = i; j > 0; j--) {
      if (arr[j] < arr[j - 1]) {
        [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]];
      } else {
        //자기보다 작은 데이터를 만나면 멈춤
        break;
      }
    }
  }
}
```

## 병합 정렬

분할 정복(divide and conquer) 알고리즘 중 하나이다.

- 시간 복잡도 O(NlogN)을 보장한다.

### 분할 정복

1.  분할(divide): 큰 문제를 작은 부분 문제(쉬운 문제)로 분할한다.
2.  정복(concuqer): 작은 부분 문제를 각각 해결한다.
3.  조합(combine): 해결한 부분 문제의 답을 이용해 다시 큰 문제를 해결한다.

일반적으로 재귀 함수를 이용해 구현한다. 큰 문제를 작은 문제로 **분할하는 방식이 동일**한 경우가 많기 때문이다.
더 이상 쪼갤 수 없는 크기가 될 때까지 계속해서 분할한다.

### 동작 방식

1. 정렬할 배열을 부분 배열 2개로 분할한다.
2. 부분 배열을 정렬한다.
3. 부분 배열을 하나의 배열로 다시 병합한다.

**정복(conquer)**

- 각 부분 배열은 이미 정렬된 상태로 본다.
- 두 부분 배열의 첫째 원소를 비교해 더 작은 값을 결과 배열을 넣는다.
- N개의 원소일 때 O(N)의 시간복잡도

### 시간 복잡도

- 높이가 O(logN)이고 너비가 O(N)인 정사각형과 유사 (분할 / 정복)
- 최악의 경우 시간복잡도 O(NlogN)

장점

- 최악의 경우에도 O(NlongN)을 보장한다.

단점

- 재귀 함수를 사용하므로 함수 호출 횟수가 많이 발생해서 **오버헤드**로 이어질 수 있다.
- 일반적인 경우 정복 과정에서 임시 배열이 필요하다.
