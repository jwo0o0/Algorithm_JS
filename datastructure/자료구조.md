# 자료구조

## 자료구조의 종류

### 선형 구조

- 배열, 연결리스트, 스택, 큐
- 데이터가 일렬로 연속적으로(순차적으로) 연결되어 있음

### 비선형 구조

- 트리, 그래프
- 하나의 데이터 뒤에 다른 데이터가 여러 개 올 수 있는 자료구조
- 데이터가 일직선상으로 연결되어 있지 않음

## 프로그램의 성능 측정 방법

1.  시간 복잡도: 알고리즘에 사용되는 연산 횟수를 측정
2.  공간 복잡도: 알고리즘에 사용되는 메모리의 양을 측정
    (공간을 많이 사용하는 대신 시간을 단축하는 방법이 흔히 사용됨)

### Big-O 표기법

- 특정 알고리즘이 얼마나 효율적인지 수치적으로 표현
- 가장 빠르게 증가하는 항만을 고려하는 표기법
- 일반적으로 연산 횟수가 10억을 넘어가면 1초 이상의 시간이 소요됨

ex. n = 1000일 때

- O(n): 약 1,000번 연산
- O(nlogn): 약 10,000번 연산
- O(n^2): 약 1,000,000번 연산
- O(n^3): 약 1,000,000,000번 연산

### 메모리의 크기

- 코딩테스트에서는 일반적으로 MB로 표기

## 배열과 리스트

### 배열

- 가장 기본적인 자료구조로 여러 개의 변수를 담는 공간
- 0부터 시작하는 인덱스가 존재한다.
- 특정 인덱스에 직접적으로 접근 가능 하다. -> 수행시간 O(1)

- 메인 메모리에서 **배열의 공간은 연속적으로 할당**됨
- 장점: 캐시 히트 가능성이 높고 조회가 빠름
- 단점: 배열의 크기를 미리 지정해야 하는 것이 일반적이므로 데이터의 추가 및 삭제에 한계가 있음
  (javascript는 기본적으로 동적 배열)

### 연결 리스트

- 메인 메모리상에서 **주소가 연속적이지 않음**
- 배열과 다르게 크기를 동적으로 변경 가능함
- 장점: 포인터로 다음 데이터의 위치를 가리킴 -> 삽입, 삭제 간편
- 단점: 특정 번째 원소를 검색할 때는 앞에서부터 찾아야하므로 데이터 검색 속도가 느리다
- 각 노드는 데이터+포인터로 이루어짐

### JavaScript의 배열

- 일반 배열처럼 인덱스를 이용해 직접적인 접근 가능
- JavaScript의 배열 자료형은 **동적 배열**이다.
- 배열 용량이 가득차면 자동으로 크기 증가
- 내부적으로 포인터를 사용해 연결리스트의 장점도 가지고 있음
- **배열 혹은 스택**의 기능이 필요할 때 사용 가능하나 **큐의 기능은 제공하지 못함**

### 연결리스트 vs. 배열

특정 위치의 데이터 삭제 시

- 배열: 최악의 경우 O(N) 소요
- 연결리스트: O(1) 소요, 물리적인 위치를 한칸씩 옮기지 않아도 삽입 가능

## 스택

- 먼저 들어온 데이터가 나중에 나가는 자료구조
- 삽입, 추출, 최상위 원소, empty 연산의 시간복잡도: O(1)
- javascript에서 스택 - 배열 자료형을 이용한다
- 삽입: push(), 삭제: pop()

## 큐

- 먼저 삽입된 데이터가 먼저 추출되는 자료구조
- 연결리스트로 구현시 삽입, 삭제 시간복잡도 O(1)
- javascript에서는 Dictionary 자료형으로 구현

## 트리

- 계층적인 구조를 표현할 때 사용하는 자료구조
- 루트 노드: 부모가 없는 최상위 노드
- 단말 노드: 자식이 없는 노드
- 노드들은 부모 관계, 형제 관계를 가짐
- 깊이: 루트 노드에서의 길이(출발 노드에서 목적지까지 거쳐야 하는 간선의 수)

### 이진 트리

- 최대 2개의 자식을 가질 수 있는 트리

1. 포화 이진 트리(full binary tree)

- 리프 노드를 제외한 모든 노드가 두 자식을 가지고 있는 트리

2. 완전 이진 트리(complete binary tree)

- 모든 노드가 왼쪽 자식부터 차근차근 채워진 트리

3. 높이 균형 트리(height balanced tree)

- 왼쪽 자식 트리와 오른쪽 자식 트리의 높이가 1 이상 차이나지 않는 트리

## 우선순위 큐

- 우선순위에 따라서 데이터를 추출하는 자료구조
- 일반적으로 힙을 이용해 구현

| 자료구조    | 추출되는 데이터             |
| ----------- | --------------------------- |
| 스택        | 가장 나중에 삽입된 데이터   |
| 큐          | 가장 먼저 삽입된 데이터     |
| 우선순위 큐 | 가장 우선순위가 높은 데이터 |

| 우선순위 큐 구현 방식 | 삽입 시간 | 삭제 시간 |
| --------------------- | --------- | --------- |
| 리스트                | O(1)      | O(N)      |
| 힙                    | O(logN)   | O(logN)   |

- 우선순위 큐: 이진 트리를 사용하는 것이 일반적임

## 힙

- 원소들 중에서 최댓값 혹은 최솟값을 빠르게 찾아내는 자료구조
- 최대 힙, 최소 힙
- 원소 **삽입과 삭제를 위해 O(logN)**의 수행시간
- 단순히 N개의 데이터를 힙에 넣었다가 꺼내는 작업 = 정렬 -> 시간복잡도 O(NlogN)
- 완전 이진 트리 자료구조를 따른다
- 우선 순위가 높은 노드가 루트에 위치

### 최대 힙(max heap)

- 부모 노드가 자식 노드보다 값이 큰 완전 이진 트리
- 루트 노드가 가장 큰 값

### 최소 힙(min heap)

- 부모 노드가 자식 노드보다 값이 작은 완전 이진 트리
- 루트 노드가 가장 작은 값

### 최소 힙 구성 함수: Heapify

- 상향식: 부모로 거슬러 올라가며 부모보다 자신이 더 작은 경우 위치를 교체
- 원소 제거시: 루트 노드를 삭제하고 가장 마지막 노드가 루트 노드가 되도록 -> 루트 노드에서부터 하향식으로 heapify 진행

### javascript 우선순위 큐 라이브러리

- https://github.com/janogonzalez/priorityqueuejs

## 그래프

- 사물을 정점(vertext)와 간선(edge)로 나타내기 위한 도구

구현 방식

1.  인접 행렬(adjacency matrix): 2차원 배열 이용
2.  인접 리스트(adjacency list): 연결 리스트 이용

### 시간 복잡도

인접 행렬

- 모든 정점의 연결 여부를 저장해 O(V^2)의 공간 필요
- 두 노드의 연결 여부를 O(1)에 확인 가능
  인접 리스트
- 연결된 간선의 정보만 저장하므로 O(V+E)의 공간 필요
- 두 노드의 연결 여부를 O(V)의 시간 필요

|             | 필요한 메모리 | 연결 여부 확인 |
| ----------- | ------------- | -------------- |
| 인접 행렬   | O(V^2)        | O(1)           |
| 인접 리스트 | O(V+E)        | O(V)           |

- 최단경로 알고리즘 구현 시: 근처 노드와 연결되어 있는 경우가 많으면 간선 개수가 적으므로 인접 리스트가 유리
